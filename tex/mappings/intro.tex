Software synthesis refers to a family of methods, rather than a concrete one, which share common properties about the abstract flow of generating code for efficient execution in (heterogeneous) multicores. While some principles apply more generally than others, to actually produce and optimize code, we need to focus on a concrete flow. In this chapter we will introduce the concepts behind software synthesis and mappings in a concrete flow, mapping KPN applications onto heterogeneous hardware. The flow can be seen in Figure~\ref{fig:sofware_synthesis_flow}, and is presented in detail in~\cite{castrillon_phd}. 

As is general in Software Synthesis, the applications to be axecuted are represented with an abstract representation linked with a model of computation, Kahn Process Networks (KPNs). Similarly, the target archtiecture is assumed to be known at compile-time, and is models via an abstract architecture model. The KPN model has a property that allows to capture the abstract execution behavior in a trace that is independent of the execution target. Combining these application and architecture models, and using an execution trace, a simulation can be used to estimate the performance of a mapping - an assignment of physical execution and communication resources on the target architecture to the logical (abstract) components of the KPN application. In an iterative process, this estimations can be leveraged to determine a near-optimal mapping subject to objective goals (e.g. execution time, energy conspmution). Finally, a compiler can lower the KPN application to an executable that uses the selected mapping.

The rest of this chapter will explore the various models refered to in this flow, with precise mathematical definitions and a discussion of common design choices and goals in this flow.

\subsection{
%older (can this go somewhere else?)
%The central concept in software synthesis as studied in this chapter is the concept of a \emph{mapping}\index{mapping}.
%In this chapter we will consider mappings and their general mathematical structure, whereas Chapter~\ref{chap:mapping_applications} will deal with concrete applications of this structure to improve different aspects of the software synthesis process.
%
%Intuitively, a mapping distributes a computation (and its corresponding data) to physical resources in a specific hardware.
%This can be done dynamically\index{mapping!dynamic}, for example as is the case with tasks scheduled by \acs{CFS} in a modern Linux-based operating system.
%Conversely, a \emph{static} mapping\index{mapping!static} as the one depicted in Figure~\ref{fig:mapping_idea} maps the computation and data statically, usually at compile time, to specific hardware resources.
%Finally, there are also \emph{hybrid} mappings \index{mapping!hybrid}, in which partial decisions are taken statically, but the final decision happens at compile-time. 

Software synthesis refers to a family of methods, rather than a concrete one, which share common properties about the abstract flow of generating code for efficient execution in (heterogeneous) multicores. While some principles apply more generally than others, to actually produce and optimize code, we need to focus on a concrete flow. In this chapter we will introduce the concepts behind software synthesis and mappings in a concrete flow, mapping KPN applications onto heterogeneous hardware. The flow can be seen in Figure~\ref{fig:sofware_synthesis_flow}, and is presented in detail in~\cite{castrillon_phd}. 

As is general in Software Synthesis, the applications to be axecuted are represented with an abstract representation linked with a model of computation, Kahn Process Networks (KPNs). Similarly, the target archtiecture is assumed to be known at compile-time, and is models via an abstract architecture model. The KPN model has a property that allows to capture the abstract execution behavior in a trace that is independent of the execution target. Combining these application and architecture models, and using an execution trace, a simulation can be used to estimate the performance of a mapping - an assignment of physical execution and communication resources on the target architecture to the logical (abstract) components of the KPN application. In an iterative process, this estimations can be leveraged to determine a near-optimal mapping subject to objective goals (e.g. execution time, energy conspmution). Finally, a compiler can lower the KPN application to an executable that uses the selected mapping.

The rest of this chapter will explore the various models refered to in this flow, with precise mathematical definitions and a discussion of common design choices and goals in this flow.

\subsection{

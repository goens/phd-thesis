%older (can this go somewhere else?)
%The central concept in software synthesis as studied in this chapter is the concept of a \emph{mapping}\index{mapping}.
%In this chapter we will consider mappings and their general mathematical structure, whereas Chapter~\ref{chap:mapping_applications} will deal with concrete applications of this structure to improve different aspects of the software synthesis process.
%
%Intuitively, a mapping distributes a computation (and its corresponding data) to physical resources in a specific hardware.
%This can be done dynamically\index{mapping!dynamic}, for example as is the case with tasks scheduled by \acs{CFS} in a modern Linux-based operating system.
%Conversely, a \emph{static} mapping\index{mapping!static} as the one depicted in Figure~\ref{fig:mapping_idea} maps the computation and data statically, usually at compile time, to specific hardware resources.
%Finally, there are also \emph{hybrid} mappings \index{mapping!hybrid}, in which partial decisions are taken statically, but the final decision happens at compile-time. 

Software synthesis refers to a family of methods, rather than a concrete one, which share common properties about the abstract flow for generating code for an efficient execution in (heterogeneous) multicores.
It can be seen as embedded in a spectrum of design approaches going from hardware design (and classical \ac{EDA}) through hardware-software co-design up to software synthesis on the other end. 
While some principles apply more generally than others, to actually produce and optimize code, we need to focus on a concrete flow.
In this chapter we will introduce the concepts behind software synthesis and mappings in a concrete flow, mapping KPN applications onto heterogeneous hardware.
The flow is an instance of the general flow from Figure~\ref{fig:software_synthesis_flows}, and is presented in detail in~\cite{castrillon2014thesis}. 


As is general in Software Synthesis, the applications to be executed are represented abstractly, linked with a model of computation, \acfp{KPN}.
Similarly, the target architecture is assumed to be known at compile-time, and is modeled via an abstract architecture model.
The \ac{KPN} model has a property that allows to capture the abstract execution behavior in a trace that is independent of the execution target.
Combining these application and architecture models, and using an execution trace, a simulation can be used to estimate the performance of a mapping - an assignment of physical execution and communication resources on the target architecture to the logical (abstract) components of the \ac{KPN} application.
In an iterative process, these estimations can be leveraged to determine a near-optimal mapping subject to objective goals (e.g. execution time, energy consumption).
Finally, a compiler can lower the KPN application to an executable that uses the selected mapping.

The rest of this chapter will explore the various models referred to in this flow, with precise mathematical definitions and a discussion of common design choices and goals.
So far we have discussed multiple \acp{MoC} with different extensions.
Most models we have focused on in this thesis are deterministic, which as explained in the introduction, is an important and useful property of a model's semantics.
We have shown determinism in \acp{KPN} allows us to simulate and analyze their execution.
Without it, many concepts we have seen in chapters~\ref{chap:mapping,chap:mapping_structures,chap:mapping_applications} breaks down.

However, the models we have discussed neglect one important aspect, time.
Computation takes time~\cite{lee2009computing}, and this is a fundamental property of its semantics which is usually implicit.
Determinism as we have discussed it here means that the output of a computation is a deterministic function of its input.
This does not mean that the time it takes is deterministic, as we have studied in~\cite{goens_scopes17}.
Especially in the context of \acp{CPS} or real-time systems, the computation time is an essential part of the functional specification of an application.
In this section we discuss the Reactor model~\cite{lohstroh_dac19}, which aims be a deterministic \ac{MoC} with timed semantics.

The reactor model is inspired by the Hewitt-Agha actor model~\cite{Agha:86:Actors}, which is a very widespread and well-known model of concurrent computation.\index{Reactors}
The actor model is neither deterministic nor timed.\index{actor model}
We make the reactor model deterministic by combining ideas from multiple paradigms~\cite{lohstroh_fdl19}, notably, through explicit discrete-event time semantics.
The reactor model thus has two distinct time notions, \emph{physical} and \emph{logical time}, ideal for \ac{CPS}.
Physical time refers to the time as elapsing in the physical part of the system, and while part of the model is thus not part of the digital logic.\index{physical time}
Logical time, on the other hand, is the digital counterpart of physical time, and is the time that governs the computation of the reactor network.\index{logical time}
Every \ac{CPS} has physical and logical time, by their very definitions. The novelty of the reactor models is making the separation explicit.
Just as in any other timed \ac{MoC} for \acp{CPS}, the two times are tightly coupled and intended to be synchronized. 
Making the separation explicit allows us to control the synchronization of both time models and have better control over a deterministic execution of the time logic.

Just as in the dataflow models discussed in Section~\ref{sec:mocs_overview} the actor model divides computation into isolated \emph{actors} that communicate solely over explicit messages.
The main difference to models like \ac{SDF} or \ac{KPN} is that actors and channels are not fixed, but can rather me dynamically created and destroyed.
In the reactor model we aim to combine good ideas from multiple established \acp{MoC}.
We permit dynamic re-configuration of the network through \emph{mutations} which are well-defined, not arbitrary~\cite{lohstroh_cyphy19}, which permits to reason about determinism more explicit. \index{Reactors ! mutation}
At the time of this writing, mutations are only defined in principle.
Specifying a set of well-defined mutations that allow us to reason about determinism and time, while still providing enough flexibility as need by the applications, is ongoing work.
We will discuss this in an example use case for 5G in Section~\ref{sec:fiveg}.

This thesis deals with model-based design in general.
As such, Reactors are part of the contribution as yet another model with distinct advantages and disadvantages.
Thus, apart from the design choices discussed, we only briefly outline the formalization of reactors as well as some applications leveraging particular features of this model as opposed to other \acp{MoC}.
The detailed design and implementation of Reactors as runtime systems and the corresponding polyglot coordination language, Lingua Franca\footnote{\url{https://github.com/icyphy/lingua-franca}}, are outside the scope of this thesis~\cite{lingua_franca,lohstroh_phdthesis}.

\subsubsection{Reactors}

The work in~\cite{lohstroh_cyphy19} laid the groundwork for a formalization of reactors.
As an ongoing project, the reactor model has been refined since. At the time of this writing, the most thorough and up-to-date account is in~\cite{lohstroh_phdthesis}.
However, we will slightly deviate from the formalization in~\cite{lohstroh_cyphy19,lohstroh_phdthesis} for two reasons.
The first reason is that the original formalization attempt has some mathematical inaccuracies and unspecified behavior.
Clarifying or correcting these inaccuracies is necessary for having a well-defined model.
In ongoing unpublished work with Marcus Rossel we are using the Lean theorem prover~\cite{lean} to formalize reactors and use this to prove that the model is deterministic.
The second reason for the deviation is the level of detail. The formalization of~\cite{lohstroh_cyphy19,lohstroh_phdthesis} sometimes conflates implementation details with the abstract underlying model.
The aim of the formalization here is to isolate the abstract model's semantics and leave implementation details out.

\paragraph{Restrictions}
We explicitly restrict ourselves to a subset of the model, leaving out mutations, startup and shutdown. These are discussed in Chapter~2 of~\cite{lohstroh_phdthesis}.
We also leave out cycles in the graphs for simplicity of the exposition, for a thorough discussion about cycles and causality loops see Chapter~2 of~\cite{lohstroh_phdthesis}.
We do not model state in reactors or reactions either. This is not a strong restriction, since it can be modeled as self-edge (with an action).

\paragraph{Formalization}
Reactors are based on logical time model of discrete events.
We formalize logical time as a totally ordered set of discrete time \emph{tags}, which is order-isomorphic to the naturals $\mathbb{N}$ (or a finite subset). \index{Reactors ! time}
When two events happen at the same time, we want to keep the total-order property to distinguish them.
For this, we use \emph{superdense time}~\cite{superdense,Ptolemaeus:14:SystemDesign}~\index{superdense time}, which adds \emph{microsteps} at every time unit.
Thus, time tags $\tau \in \mathbb{N} \times \mathbb{N}$ are lexicographically ordered tuples of natural numbers, where the first number represent the time ticks (in some specific unit of time), and the second number represents microsteps.
Physical time, on the other hand, we define as real numbers $\mathbb{R}$ to allow continuous-time physical models (e.g. Newtonian mechanics).
However, computation only can interact with physical time at discrete time intervals ($\mathbb{N} \hookrightarrow \mathbb{R}$).

As computation is the manipulation of data, models are built and defined by how they manipulate data.
We follow a model of computation based on the Scott model (cf. Section~\ref{sec:mocs_overview}).
Data are thus sequences $s \in S = \Sigma^* \cup \Sigma^\omega$ over a finite alphabet $\Sigma$, which we require to include a special symbol $\bot \overset{!}{\in} \Sigma$ that represents absence of data.
The basic unit of computation in Reactors are reactions, which take a finite number of data tokens as input and return a finite number as output.
Thus, a \emph{reaction} is simply a Scott-continuous function $r : S^n \rightarrow S^m$\index{Reactors ! reaction}
Note that this restricts the definition of reactions.
As defined in~\cite{lohstroh_cyphy19} with an informal \emph{source code} ``object'', they can interpreted in the semantics of the language of that source code.
As such, they could implement any relation on $S^n \times S^m$.
In particular, we assume reactions are deterministic (as mathematical functions) and respect causality (being Scott-continuous).
\todo{make sure notation is consistent with Scott definition at beg. of chapter}

We define 
Actions
\index{Reactors ! actions}

Atomic reactors

Reactors
\index{Reactors ! reactor}
\index{Reactors ! triggers}

Reactor Networks

Execution
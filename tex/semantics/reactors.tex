So far we have discussed multiple \acp{MoC} with different extensions.
Most models we have focused on in this thesis are deterministic, which as explained in the introduction, is an important and useful property of a model's semantics.
We have shown determinism in \acp{KPN} allows us to simulate and analyze their execution.
Without it, many concepts we have seen in chapters~\ref{chap:mapping},\ref{chap:mapping_structures} and \ref{chap:mapping_applications} break down.

However, the models we have discussed neglect one important aspect, time.
Computation takes time~\cite{lee2009computing}, and this is a fundamental property of its semantics which is usually implicit.
Determinism as we have discussed it here means that the output of a computation is a deterministic function of its input.
This does not mean that the time it takes is deterministic, as we have studied in~\cite{goens_scopes17}.
Especially in the context of \acp{CPS} or real-time systems, the computation time is an essential part of the functional specification of an application.
In this section we discuss the Reactor model~\cite{lohstroh_dac19}, which aims be a deterministic \ac{MoC} with timed semantics.

The Reactors model is inspired by the Hewitt-Agha actor model~\cite{Agha:86:Actors}, which is a very widespread and well-known model of concurrent computation.\index{Reactors}
The actor model is neither deterministic nor timed.\index{actor model}
Determinism in Reactors comes from combining ideas from multiple paradigms~\cite{lohstroh_fdl19}, notably, through explicit discrete-event semantics.
The reactor model has two distinct time notions, \emph{physical} and \emph{logical time}.
Physical time refers to the time as elapsing in the physical part of the system, and that part of the model is thus not part of the digital logic.\index{physical time}
Logical time, on the other hand, is the digital counterpart of physical time, and is the time that governs the computation of the reactor network.\index{logical time}
Every \ac{CPS} has physical and logical time, by their very definitions. A novelty of the reactor models is making both time concepts and their separation explicit.
Just as in any other timed \ac{MoC} for \acp{CPS}, the two times are tightly coupled and intended to be synchronized. 
Making the separation explicit allows us to control the synchronization of both time models and have better control over a deterministic execution of the time logic.

Just as in the dataflow models discussed in Section~\ref{sec:mocs_overview}, the actor model divides computation into isolated \emph{actors} that communicate solely over explicit messages.
The main difference to models like \ac{SDF} or \ac{KPN} is that actors and channels are not fixed.
Instead,they can be dynamically created and destroyed.
In Reactors we aim to combine good ideas from multiple established \acp{MoC}.
We permit dynamic re-configuration of the network through \emph{mutations} which are well-defined (not arbitrary) transformations of the network's topology~\cite{lohstroh_cyphy19}.
This permits us to reason about determinism more explicitly. \index{Reactors ! mutation}
At the time of this writing, mutations are only defined astractly.
Specifying a set of well-defined mutations that allow us to reason about determinism and time, while still providing enough flexibility as need by the applications, is ongoing work.
We will discuss this in an example use case for 5G in Section~\ref{sec:5g}.

This thesis deals with model-based design in general.
As such, Reactors are part of the contribution as yet another model with distinct advantages and disadvantages.
Thus, apart from the design choices discussed, we only briefly outline the concepts behind reactors and a simplified denotational semantics, as well as some applications leveraging particular features of this model as opposed to other \acp{MoC}.
The detailed design and implementation of Reactors as runtime systems and the corresponding polyglot coordination language, Lingua Franca\footnote{\url{https://github.com/icyphy/lingua-franca}}, are outside the scope of this thesis~\cite{lingua_franca,lohstroh_phdthesis}.

\subsubsection{Denotational Semantics}

In~\cite{lohstroh_cyphy19} we laid the groundwork for an operational formalization of reactors.
As part of an ongoing project, the reactor model is a moving target and has been refined since.
At the time of this writing, the most thorough and up-to-date account is in~\cite{lohstroh_phdthesis}.
Here we will deviate from the formalization both in~\cite{lohstroh_cyphy19} and \cite{lohstroh_phdthesis}, however, and attempt a denotational approach to semantics.
In ongoing unpublished work with Marcus Rossel, we are using the Lean theorem prover~\cite{lean} to formaly verify reactors, proving properties like determinism under certain conditions.
A reason for this denotational approach is that the original formalization has some mathematical inaccuracies and unspecified behavior.
Clarifying or correcting these inaccuracies is necessary for having a well-defined model.
The second reason for the deviation is the level of detail.
We want to simplify the formalization of~\cite{lohstroh_cyphy19,lohstroh_phdthesis}.
The aim of the formalization here is to isolate the abstract model's (denotational) semantics and leave implementation-specific details out as much as possible.
An advantage of this formalization is that it relates \acp{KPN} and Reactors formally.

\paragraph{Restrictions}

We explicitly restrict ourselves to a subset of the model, leaving out mutations and any kind of exception-handling policies.
A more comprehensive (operational) model, including some of these concepts, is discussed in Chapter~2 of~\cite{lohstroh_phdthesis}.
These restrictions are in part for simplicity, but also due to this being ongoing work.
At the time of this writing, we have not finished the Lean-based formalization to include these aspects.
Extending a simple model is easier than changing a complete model that is problematic.
It is important to note that as ongoing work, this alternative formulation has not yet undergone peer-review (as opposed to~\cite{lohstroh_cyphy19}) and is subject to change.

\subsubsection{Timeless model}

Reactors are a timed model, with specific semantics of how the time progresses and what can happen when.
The logical (functional) semantics of a reactor network are complex as well, however.
We first begin defining the computational semantics of the network in a timeless fashion, and then extend the model to include time.

Computation is essentially manipulation of data.
Models are thus built and defined by how they manipulate data.
We follow a model of computation based on Scott's semantics of computation (cf. Section~\ref{sec:mocs_overview}).
Data is modeled as sequences $s \in S = \Sigma^* \cup \Sigma^\omega$ over a finite alphabet $\Sigma$, which we require to include a special symbol $\bot \overset{!}{\in} \Sigma$ that represents absence of data.
%\todo{make sure notation is consistent with Scott definition at beg. of chapter}
The basic unit of computation in Reactors are reactions, which take a finite number of data tokens as input and return a finite number as output.
Thus, to define a reaction we simply consider a Scott-continuous function $n : S^k \rightarrow S^m$.
Sequences can have different lengths (both finite or infinite), yet reactor networks execute in discrete ticks, which result in sequences of the same length.
To model this we define ``padding'' using the special symbol $\bot \in \Sigma$ on a finite sequence $s \in \Sigma^* = S \setminus \Sigma^\omega$, by defining $\hat s  = s.(\bot^\omega)$. 
%Similarly, we define $\hat n = n_{\big| \Sigma^\omega}$ as the restriction of $n$ to infinite sequences. 
Finally, an important restriction is that we want to ensure reactions do not to take multiple inputs from the same channel before producing an output. 

\begin{defn}[Reaction]\index{Reactors ! reaction}
    \label{defn:reaction}
Let $n : S^k \rightarrow S^m$ be a Scott continuous function. 
We call $n$ a \emph{reaction} if for any two $s, s' \in S$ such that $s'$ is a proper prefix\footnote{Not to be confused with $s' \not \sqsubseteq s$, the negation of $s' \sqsubseteq s$.} of $s$, i.e. $s' \sqsubsetneq s$, then this also holds for the images under $n$, i.e. $n(s') \sqsubsetneq n(s)$.
\end{defn}

Note that our definition is a restriction on the definition of reactions.
As defined in~\cite{lohstroh_cyphy19} with an informal \emph{source code} ``object'', they can be interpreted in the semantics of the language of that source code.
As such, they could implement any relation on $S^k \times S^m$.
In particular, we assume reactions are deterministic (as mathematical functions) and respect causality (being Scott-continuous).
Note that this does not mean they are stateless.
State is implicit in the definition of a function on the complete history of inputs, as opposed to a function on a single input token.
In the latter, for $f : \Sigma^k \rightarrow \Sigma^m$, state can be formalized as a ``self-edge'' i.e. an $i,j$ such that
\[ f(*,\underbrace{s}_{i},*) = (*,\underbrace{s'}_{j},*) \text{ with } s ,s' \in \Sigma, \]
the $*$ being other values we don't care about here.
However, we use the denotational formalization of computation of functions by Scott as complete sequences of inputs and outputs, which makes the state implicit.

Definition~\ref{defn:reaction} also has strong theoretical consequences.
It implies that every monotone reaction is Scott-continuous, since it is equivalent with $|f(s)| \geq |s|$ for all $s \in S$, which avoids the pathological cases that distinguish monotone and Scott-continuous functions.
Proving this fact is beyond the scope of this thesis.

Modeling reactions as Scott-continuous functions, we do not specify anything about the \emph{length} of the sequences.
A reaction might produce a longer output sequence than its input sequence. At this stage this is not important, as we model the complete computation with a single function.
We will come back to this later, in the timed model, when we relate these sequences to concrete times.

If a reaction $f : S^k \rightarrow S^m$ has the property that
\[ f(s_1,\ldots,s_{i-1},\bot,s_{i+1},\ldots,s_k) \sqsubseteq (\bot^\omega,\ldots,\bot^\omega)\text{ for all }s_j \in S, 1 \leq j \leq k, j \neq i,\]
 we say that $f$ has a trigger on the input $i$.
Recall that the symbol $\bot$ represents the absence of values.
Intuitively, thus, a reaction that triggers on $i$ will not execute if there is no input on $i$.
In other words, the values in $i$ trigger the reaction, hence the name.\index{Reactors ! triggers }
Besides triggers, the original definition also has other components as part of reactions, namely sources and effects (or dependencies and anti-dependencies), scheduleable actions and a deadline.
We include most of these concepts in other definitions, e.g. the reactor or the network.

To communicate between reactors (or perhaps more precisely, between reactions), we need to send and receive data.
We do this using input and output ports, which we model simply as identifiers in an index or identifier set $I$. 
A reactor has a series of reactions with input and output ports, and reactors connect to each other through them.

\begin{defn}[Reactor]
\label{defn:reactor}
Let $I$ be an index set. A reactor is a tuple $r = (N,D,D^\vee)$  where $N$ is a finite \ac{poset} of reactions $n : S^{k_n} \rightarrow S^{m_n}$ and
 \begin{align*} D : & N \rightarrow (\{1, \ldots, k_n\} \rightarrow I), \\
     D^\vee : & N \rightarrow (\{1, \ldots, m_n\} \rightarrow I),
 \end{align*} are called the sources and effects respectively.
We define the set of input ports as $\operatorname{Input}(r) = \bigcup_{ n \in N} \operatorname{im}(D(n))$  and, 
similarly, the set of output ports we define as $\operatorname{Output}(r) = \bigcup_{ n \in N} \operatorname{im}(D^\vee(n)).$
We require that $\operatorname{Input}(r) \cap \operatorname{Output}(r) = \emptyset$ as part of the definition of a reactor.
\end{defn}
\index{Reactors ! reactor }
\index{Reactors ! sources }
\index{Reactors ! effects }

The sources $D$ make a correspondence between the indices in the tuple of input streams of a reaction and the (port) identifiers $I$.
For example, if a reaction $n : S^2 \rightarrow S$ takes two inputs, $D(n) : 1 \mapsto c, 2 \mapsto b$ means that the ports $c$ and $b$ are the two input ports of $n$, in that order.
The effects $D^\vee$ are analogous but for the outputs of the reaction.

We require $N$ to be a \ac{poset} for two reasons.
Firstly, we want to be able to specify an order in which reactions are always executed.
However, we also want to allow explicitly making the model non-deterministic by making reactions incomparable. 
When two reactions are incomparable, they are executed in a non-deterministic order.
By the order-extension principle, it is always possible to execute reactions while respecting the partial order.

More formally, let $n, n' : S \rightarrow S$ be two reactions.
For simplicity, we assume they have a single (shared) input and output port: $(D(n))(1) = (D(n'))(1)$ and similarly $(D^\vee(n))(1) = (D^\vee(n'))(1)$.
Recall that $\hat s = s.(\bot)^\omega$ for $s \in S \setminus \Sigma^\omega$ is a ``padding'' of a sequence with absent values.
We say that a function $f : S \rightarrow S$ is a \emph{priority-preserving execution} if for all $s \in S$ and for all $i \in \mathbb{N}$, it holds that:
\begin{align}
\label{eqn:nleqns} (\hat f(\hat s))_i &  =  (\hat n(\hat s))_i, & \text{ if } n \leq n', (\hat n(\hat s))_i \neq \bot \\
\label{eqn:nleqnsbot} (\hat f(\hat s))_i &  =  (\hat n'(\hat s))_i, & \text{ if } (\hat n(\hat s))_i = \bot \\
\label{eqn:nsleqn} (\hat f(\hat s))_i &  =  (\hat n'(\hat s))_i, & \text{ if } n' \leq n, (\hat n(\hat s))_i \neq \bot \\
\label{eqn:nleqnsbot} (\hat f(\hat s))_i &  =  (\hat n(\hat s))_i, & \text{ if } (\hat n'(\hat s))_i = \bot \\
\label{eqn:nondet} (\hat f(\hat s))_i &  \in \{ (\hat x(\hat s))_i \mid x \in \{n,n'\} \} & \text{ otherwise }
\end{align}

In this case we write $f \in \bigsqcup_{D,D^\vee} \{n, n'\}$.
Equations~\ref{eqn:nleqns} and~\ref{eqn:nsleqn} formalize the reaction priority when the two reactions are ordered, and Equation~\ref{eqn:nondet} the non-deterministic ordering when $n$ and $n'$ are incomparable.
If a reaction returns an absent value $\bot$, then the value of the other reaction is written on the output sequence.
Note when $n \leq n'$ or $n' \leq n$ (which trivially includes the case $n = n'$), all functions in $\bigsqcup_{D,D^\vee} \{n,n'\}$ are equivalent up to padding with $\bot$. 

This definition can be trivially generalized to more than one (shared) input or output sequence (componentwise), and to non-shared input or output sequences by requiring equations~\ref{eqn:nleqns}-\ref{eqn:nondet} to hold quantified over all non-shared sequences.
Finally, for a \ac{poset} $N$ of reactions, we define $\bigsqcup_{D,D^\vee} N$ analogously (componentwise), requiring equations~\ref{eqn:nleqns}-\ref{eqn:nondet} to hold paairwise for any two $n, n' \in N$.

%\begin{lem}
%    Let $r = (N,D,D')$ be a reactor and let $N$ be totally ordered.
%    Then, there is a unique function $f \in \sqcup_{D,D^\vee} N$ and $f$ is both Scott-continuous and minimal with regard to the prefix order on the image.
%    \begin{proof}
%        For simplicity, we show the case for $ N = \{n, n' \}, n, n': S \rightarrow S$ each with a shared sequence, i.e. $(D(n))(1) = (D(n'))(1)$ and $(D^\vee(n))(1) = (D^\vee(n'))(1)$.
%        The general case works in the same way.
%        Since $N$ is totally ordered, one of $n < n'$ or $n' < n$ holds. Without loss of generality, let $n < n'$.
%        Then, by definition, both Equation~\ref{eqn:nleqns} and Equation~\ref{eqn:nleqnsbot} hold, which defines $f(s)$ for all $s \in S$ up to concatenation with a sequence $\{\bot\}^* \cup \{ \bot^\omega \}$.
%        Let thus $f$ be the minimal element with respect to prefixes on the image, which exists because $S$ is a complete semilattice.
%        We just need to show that $f$ is Scott continuous.
%        Because $n,n'$ are reactions, $f$ also has the property that $|f(s)| \geq |s|$ for all $s \in S$.
%        It thus suffices to show that $f$ is monotone.
%        Let $s, s' \in S$ with $s \sqsubsetneq s'$.
%        This means that there exists a $t \in S$ with $s.t = s'$.
%        We prove this first for finite words $t$ by induction on the length of $t$:
%        Let ...
%
%    \end{proof}
%\end{lem}

Reactors are connected in networks. We model these networks explicitly, separate from reactors themselves.
In the original definition, this is avoided by building reactors hierarchically.
There is no semantic distinction between a hierarchical model and a flat model, where all contained reactors are ``inlined'' a network\footnote{Note
 that this might change if we extend the model to include mutations.}.
We prefer separating the reactors and their networks, since the definition of reactor networks allows us to specify the semantics of how they can be connected.
Here, we distinguish between two cases: an untimed one, which we call timeless and represents the purely logical execution of the network,
and a timed one, which is the general case and is built on top of the former.\index{Reactors ! timeless network}

\begin{defn}[Timeless reactor network]
    \label{defn:timeless_network}
A timeless reactor network is a multigraph $\mathcal{R} = (V,E,\xi)$ with a set of reactors as nodes $V$,
a set of edges $E$, which we require to be pairs of indices, $E \subseteq I \times I$ and $\xi : E \rightarrow \{ \{r_1, r_2\} \mid r_1, r_2 \in V \}$.
For this multigraph we require that for any two distinct reactors $r_1 \neq r_2 \in V$ the input and output ports are paairwise disjoint,
i.e. $\operatorname{Input}(r_i) \cap \operatorname{Output}(r_j) = \emptyset$ for all $i,j \in \{ 1, 2 \}$ and every edge is a tuple consisting of an output port and an input port,
i.e. for all $(i,j) = e \in E \subseteq I \times I$ there exist $r_1,r_2 \in V$ such that $i \in \operatorname{Output}(r_1)$ and $j = \operatorname{Input}(r_2)$.
We additionally require that the multigraph has no self-edges, i.e. $|\xi(e)| > 1$ for all $e \in E$.
\end{defn}

Recall that a multigraph is a graph that can have multiple edges, and the function $\xi : E \rightarrow \{ \{r_1, r_2\} \mid r_1, r_2 \in V \}$ defines which vertices are connected by each edge.
Here, the edges themselves carry semantics as well. They define which ports specifically they connect in the reactor.
We define the set $I(\mathcal{R}) = \bigcup_{r \in V}(\operatorname{Input}(r) \cup \operatorname{Output}(r))$ as the set of ports of $\mathcal{R}$.

We make an additional remark about Definition~\ref{defn:timeless_network}, namely that we don't require all ports to be connected.
Indeed, some ports we explicitly want to leave disconnected to define the general, timed model. 

\subsubsection{Timed Networks}

We are finally ready to introduce time into the model.
Reactors are based on a logical time model of discrete events.
We formalize logical time as a totally ordered set of discrete time \emph{tags}, which is order-isomorphic to the naturals $\mathbb{N}$ (or a finite subset). \index{Reactors ! time}
When two events happen at the same time, we want to keep the total-order property to distinguish them.
For this, we use \emph{superdense time}~\cite{superdense,Ptolemaeus:14:SystemDesign}~\index{superdense time}, which adds \emph{microsteps} at every time unit.
Thus, time tags $t \in \mathbb{N} \times \mathbb{N}$ are lexicographically ordered tuples of natural numbers, where the first number represent the time ticks (in some specific unit of time), and the second number represents microsteps.
Physical time, on the other hand, we define as real numbers $\mathbb{R}$ to allow continuous-time physical models (e.g. Newtonian mechanics).
However, computation only can interact with physical time at discrete time intervals.
We compose these two types of time in a unique time object, a \emph{tag}.

\begin{defn}[tag]
    \label{defn:tags}
   A (time) tag $t \in \mathbb{T}$ is a value in the sum (type) $\mathbb{T} := (\mathbb{N} \times \mathbb{N}) \oplus \mathbb{R} = (\mathbb{N} \times \mathbb{N}) \dot{\cup} \mathbb{R}$, which is commonly also called the disjoint sum\footnote{In the language of set theory, that we use by convention in this thesis.}.
   The embedding for the first component $\mathbb{N} \times \mathbb{N} \hookrightarrow \mathbb{T}$ is called \emph{logical} time, and the embedding from the second component $\mathbb{R} \hookrightarrow \mathbb{T}$ is called physical time.
   We say that $t$ is a \emph{logical} or \emph{physical} time tag respectively.
\end{defn}

Note that Definition~\ref{defn:tags} differs from~\cite{lohstroh_cyphy19,lohstroh_phdthesis}.
The rationale for this is that this definition gives us a uniform way of referring to time while still distinguishing between logical and physical time.
We could also have we defined $\mathbb{T} = (\mathbb{N} \times \mathbb{N}) \oplus \mathbb{N}$ taking into account only the discrete measurements of time that are available to the digital component of the \ac{CPS}.
This definition with the real numbers $\mathbb{R}$ instead allows the model to be combined with continuous-time models of physical time, and it adds no restrictions to our semantics.

Reactions are, in a sense, controlled functions we compute from incoming data. 
Some data we have no control over, like incoming input (e.g. from a sensor), or an asynchronous computation we scheduled.
To model these we use \emph{actions}.
Note that these actions are more a model of (tagged) data, as opposed to reactions which are a model of computation.
This creates a false dichotomy, since actions are fundamentally different from reactions.
Actions are more closely related to the input and output ports, and the naming confusion might be thus easier to resolve when thinking that, in this way, reactions react to actions.

Actions are central to the model, since they are the mapping between the functional world of reactions and the time semantics. \index{Reactors ! actions}
Definition~\ref{defn:action} ensures actions do not mix the two different time types, and respect causality (i.e. an action cannot change the past).

\begin{defn}
    \label{defn:action}
Let $\mathbb{T}_\text{discrete} := \{ \mid T \subseteq \mathbb{T} \mid T \text{ is discrete}  \}$ be the set of discrete subsets of $\mathbb{T}$.
An action is a partial\footnote{See Section~\ref{sec:partial_symmetries} for the required definitions.} function $A : \mathbb{T}_\text{discrete} \rightarrow S$ such that
\begin{itemize}
    \item For all $T \in \operatorname{dom}(A)$, the discrete set of tags $T$ and the corresponding sequence $A(T)$ are order-isomorphic (in particular, $|T| = |A(T)|$).
    \item All $T \in \operatorname{dom}(A)$ are either sets of logical or physical tags, i.e. $T \subseteq \mathbb{N} \times \mathbb{N}$ or $T  \subset \mathbb{R}$. We call $A$ a \emph{logical} or \emph{physical} action, respectively.
\end{itemize}
\end{defn}

For a discrete set of times $T \in \mathbb{T}_\text{discrete}$, with $\mathbb{T}_\text{discrete}$ as in Definition~\ref{defn:action}, we call $d(T) = \operatorname{inf}_{t < t' \in \operatorname{dom}(A)} t' - t$ the minimum delay or spacing of the time set $T$. 
For an action $A$ we define $d(A) = \operatorname{inf}_{T \in \operatorname{dom}(A)} d(T)$
Note that~\cite{lohstroh_phdthesis} distinguishes between the minimum delay as specified by the programmer and the minimum (time) spacing as acceptable for the runtime system.
We consolidate both here, since, for simplicity, we disregard policies for when this spacing is violated and error handling in general.
Consequently, we also do not model the spacing violation policy included in~\cite{lohstroh_phdthesis}. 
We define it also for the time set and not the action, since our semantics are denotational and not operational.

%At this point it is important mentioning a limitation of our model which might not be immediately obvious.
%The way we define time $\mathbb{T}$ we exclude infinity. Thus, while $\mathbb{T}$ is a \ac{poset}, it is not ($\omega$-)complete.
%This means we cannot model some asymptotic time behavior, but for any finite execution, as will always be the case in practice, this should not be problematic.
%In future work we could extend the definition of time to include infinity, especially if we find a use-case where this distinction is relevant in practice.

Definition~\ref{defn:action} allows us to associate any given subset of times to a different sequence of values.
In particular, this allows us to model the timestamps themselves being part of the value in the sequence, e.g. for a reaction that stores the current time to a log file.

The order-preserving bijection between a discrete set of tags and sequences ensures a causal execution.
Since the mapping is order-preserving, a going forward in timestamps can only increase the port's history (the sequence of values).
Similarly, adding tokens to the port's history can only move forward in time. 
Moreover, since it is a bijection, it means that adding tokens to the port's history \emph{has} to move forward in time, and vice-versa.
One step in the discrete set of tags corresponds to exactly one value in the history.
In particular, time has to advance every time reactions are executed. 
This is why we need microstep delays in logical time, so that we can execute events with identical logical timestamps.
For physical time we cannot have two events with identical timestamps, but the timestamps can be arbitrarily close to each other, so this is not a very strong restriction.
Note that in~\cite{lohstroh_phdthesis} physical time gets converted to logical time when assigned a tag. 
In that formalism it is thus possible for two physical actions to have values with identical tags, but the tags would ultimately have different microstep units when executed\footnote{This is an unavoidable source of non-deterimnism.}.
This is not different from e.g. adding a small enough $\epsilon > 0$ in this model.

\begin{defn}[Reactor network]
    \label{defn:reactor_network}
    A reactor network is a tuple $(\mathcal{R},\tau)$, where $\mathcal{R} = (V,E,r)$ is a timeless reactor network and $\tau : I(\mathcal{R}) \rightarrow \mathcal{A}$ is a partial function of the identifier set (of ports) of $\mathcal{R}$ to a set of actions $\mathcal{A}$, such that 
    for every $i \in I = I(\mathcal{R})$, exactly one of the following is true: $i \in \operatorname{dom}(\tau)$ or there exist an edge $e$ in $E_{\mathcal{R}}$, such that $e = (i,j)$ or $e = (j,i)$ for an $i \neq j \in I$.
\end{defn}

We call $\operatorname{im}(\tau) \subseteq \mathcal{A}$ the set of actions of the reactor network $(\mathcal{R},\tau)$.
Here, the mapping $\tau$ relates actions with all dangling ports in the timeless network.
The last condition on $\tau$ ensures that no ports are left dangling in the (timed) reactor network.

Both our original description in~\cite{lohstroh_cyphy19} and the updated one in~\cite{lohstroh_phdthesis} are very explicit about reaction and event queues, scheduling and mutexes.
These are very important aspects for any implementation of the model, yet they conflate the implementation and the semantics.
Here we are interested mostly in the general concepts behind reactors, the implementation is outside the scope of this thesis.
As a consequence, we rather err on the side of abstraction, by preferring to abstract away details and clarify them in future work if necessary. 

\begin{defn}[Execution of reactor networks]
    \label{defn:execution_reactors}
Let $T \subseteq \mathbb{T}$ be a discrete set of time tags and let $(\mathcal{R},\tau)$ be a reactor network.
We denote by $\mathcal{R}_\tau(T)$ the network obtained by substituting in the timeless network $\mathcal{R}$ for each port $i \in \operatorname{dom}(\tau)$ the sequence $(\tau(i))(T)$ (recall that $\tau(i)$ is an action).
An execution of $\mathcal{R}$ with discrete set of time tags $T$ is a sequence $s_i$ for every port $i \in I$ such that: 
\begin{enumerate}
    \item\label{cond:reactions} For every reactor $r = (N,D,D^\vee)$ in $V_\mathcal{R}$ there exists a function $f \in \bigsqcup_{D,D^\vee}N$ with $f(s_{i_1},\ldots,s_{i_k}) = (s_{j_1},\ldots,s_{j_m})$ where $i_1,\ldots,i_k,j_1,\ldots,j_m$ are the corresponding ports of $r$ according to the edges $E$ of $\mathcal{R}_\tau(T)$.
    \item\label{cond:fixpoint} For every $f$ as in~\ref{cond:reactions}, the sequences $(s_i)_{i \in I(\mathcal{R})}$ are a fix-point of the set of equations defined by the network $\mathcal{R}_\tau(T)$.
    \item\label{cond:actionsunique} For every time value $t \in T$, exactly one action $A$ is non-absent, i.e. $| \{ A  \in \operatorname{im}(\tau) \mid A(t) \neq \bot \}| = 1$.
\end{enumerate}
\end{defn}

The execution of a reactor network in this way is not modeled as an iterative process.
The computation itself is modeled through the sequences $S$ in the Scott semantics of computation.
The time values of actions $A$ are chosen (non-deterministically) for an execution, modeling the non-determinism from the environment.
Condition~\ref{cond:reactions} in Definition~\ref{defn:execution_reactors} defines the execution priority of reactions. This, together with Condition~\ref{cond:fixpoint} ensure that reactions have well-defined semantics.
Finally, Condition~\ref{cond:actionsunique} ensures that only one action is scheduled at a time.

A central idea behind Reactors is to split logical and physical time explicitly.
However, these two time concepts are conceptually linked, since logical time is just a digital estimation of physical time.
Thus, the reactor runtime should strive to synchronize these two time concepts whenever possible.
This is realized by the requirement of executing events in timestamps order, ensuring logical time never goes past physical time.
Nothing guarantees that the converse does not happen, however.
Physical time could go far beyond logical time.
In an implementation, and indeed in the formalization of~\cite{lohstroh_phdthesis}, a deadline in the reactions controls how far away logical time can lag behind physical time. 

Note that the definition of reactor networks does not exclude any loops.
The fixpoint-based definition allow us to have well-defined semantics with such loops (cf. ~\cite{kahn74,lee_matsikoudis_semantics}),
as ensured by Condition~\ref{cond:fixpoint} in Definition~\ref{defn:execution_reactors}.
In some cases, however, the least fix-point of the network might result in an empty sequence.
This can be the case when the ordering in reaction causes a so-called causality loop.
See Section~2.6 of~\cite{lohstroh_phdthesis} for a more thorough discussion.
Also note that Condition~\ref{cond:fixpoint} does not require the fix-point to be minimal, but this is given by the order-isomorphism condition on actions.

In~\cite{lohstroh_phdthesis}, reactors are explicitly required to have two special actions, a startup and a shutdown action.
We do not require these two actions explicitly.
An empty reactor network, that does nothing, is also a well-defined reactor network, albeit a pretty useless one.

\begin{conjecture}[Reactors are deterministic]
    \label{conjecture_reactors_deterministic}
Let $(\mathcal{R},\tau)$ be a reactor network such that for every reactor $r = (N,D,D^\vee)$ the set $N$ is totally ordered.
Then for every execution $\mathcal{R}_\tau(T)$ with a discrete time set $T$ the values of $s_i$ for every port $i \in I$ are uniquely specified.
\end{conjecture}

Our formalization has allowed us to specify determinism in reactors in a mathematically precise fashion.
We believe in future work we can prove Conjecture~\ref{conjecture_reactors_deterministic} with fixpoint theorems for the corresponding Scott-continuous functions, similar to~\cite{kahn74}.

This also gives us the language to discuss different kinds of determinism: can the values be independent of the set of time tags $T$?
In general, it cannot work. Consider a network which prints the timestamps it sees, this will never be independent of the timestamps.
On the other hand, if every discrete sequence of timestamps is mapped to the same sequence of values, i.e. $A(T) = A(T')$ for all actions $A$ and (valid) sequences of timestamps $T, T'$, then the behavior is trivially time-deterministic.
Note that in this case, Definition~\ref{defn:action} implies that $T \cong T'$ are order isomorphic and, consequently, $T = T'$, which is a very strict condition on the network, that has to have a constant number of actions.
There are certainly relaxations of this that allow us to define reasonable conditions for time-determinism.

We can even go further and distinguish between logical and physical actions for determinism. 
For example, we can define a reactor network to be time-deterministic if it only dependends on the image sequences of \emph{physical} actions $A$.
The non-determinism from the physical world is outside our control, but with this definition we are also ensuring logical actions to behave deterministically as a function of the physical ones. 

A final word on distributed execution, which we have ignored so far, is due here. 
Our semantics are denotational, they are meant to describe what is computed, not how. 
In particular, a distributed execution should adhere to these semantics just as a sequential one.
A fundamental problem with using our model for distributed execution, however, are time tags, which are uniform in the model.
Strictly speaking, we could replace our Newtonian model of time with a relativistic one and consider different frames of reference and transformations. 
The model, as is, can thus be considered a model for a fixed (inertial) frame of reference.

In future work we plan to consider distributed execution and its consequences (or lack thereof) on our denotational semantics. 
We also plan to precisely identify conditions for these different possible definitions of determinism and verify them, using the Lean theorem prover~\cite{lean} and a formalization similar to the one described here.
As mentioned above, this is ongoing (unpublished) work with Marcus Rossel.
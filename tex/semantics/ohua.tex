This section reviews some programming languages and how they provide ``freedom from choice'' in the sense of A. Sangiovani-Vincentelli~\cite{lee2019freedom}.
There is a distinct sense in this is the central question of programming languages in general.
By removing memory management through having no pointer arithmetic and garbage collection, Java frees its users from multiple families of errors that are possible in C.
Rust's ownership types take a different approach, also removing complete families of memory-management based errors, without introducing large performance overheads or unpredictable behavior from the garbage collector.

These kinds of ``freedom from choice'' in general-purpose languages are beyond the scope of this thesis, which focuses on \acp{MoC} like those described in Chapter~\ref{chap:mocs}.
In well-defined \acp{MoC} like the ones discussed here, on the other hand, the temptation to break away from the semantics might be higher.
A very interesting observation and discussion of this phenomenon can be found in~\cite{tasharofi2013scala}, which shows not only that developers commonly break away from the semantics if they are not enforced, but also gives multiple explanations why.
This is why it is not advisable to expose these as a library, but rather as a full language, as much as possible. 
Here we will briefly survey languages focused on \ac{MoC}-based paradigms.

\subsection{Dataflow, Actors and Discrete Events}
\label{sec:general_dataflow_tools}

Most well-known languages that follow \acp{MoC} like the ones described here are based on the actor model.
Compared to more sophisticated models, the actor model has mostly intuitive semantics.
The Erlang language is a successful example of a language whose semantics are in principle an implementation of the (Hewitt-Agha) actor model.\index{Erlang}
The Rebeca language~\cite{sirjani2004formal}, which is primarily a design and specification language used in model checking, is also an actor-based language.\index{Rebeca}
Another prominent example is the CAL actor language~\cite{eker2003cal}, and has been used to define the \ac{RVC} standard~\cite{bhattacharyya2011overview}.
The \ac{RVC}-CAL compiler\footnote{\url{https://sourceforge.net/projects/orcc/}} is an Eclipse-based compiler for the CAL actor language which is used to compile the \ac{RVC} reference implementations.\index{\ac{RVC}-CAL}

Another prominent \ac{MoC}-based programming environment from academia is Ptolemy~II\cite{Ptolemaeus:14:SystemDesign}. 
In contrast to most of the other frameworks, Ptolemy~II supports a plethora of \ac{MoC}, including most of the models discussed in this thesis. 
Also in contrast to most other frameworks, \acp{MoC} are a central component of Ptolemy~II, which makes them explicit using \emph{directors}\index{Ptolemy~II}.
The framework uses the Java programming language to allow the definition of arbitrary actors, but it also comes with a large library of pre-defined actors.
Figure~\ref{fig:audio_filter_ptolemy} shows an implementation of an audio filter, which while not identical, is semantically similar to our running example described in Chapter~\ref{chap:mapping}.
This implementation uses only pre-defined actors in Ptolemy~II.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/audio_filter_ptolemy_screenshot.png}
	\caption{An audio filter in \ac{SDF} semantics in Ptolemy II}
	\label{fig:audio_filter_ptolemy}
	%	\vspace{-1mm}
\end{figure}

In the case of discrete-event models, there are many more well-established languages which implement them.
The hardware description languages VHDL and Verilog work with discrete-event semantics, since hardware does. 
The SystemC language, well known for discrete event simulations (of hardware), also has discrete event semantics~\cite{semantics_systemc}.
Finally, more on the software side are the Synchronous languages, like LUSTRE~\cite{lustre} or ESTEREL~\cite{esterel}, which are (complete) programming languages with a discrete event semantics.

Also in the discrete events domain is the Lingua Franca language~\cite{lohstroh_fdl20}\footnote{\url{https://github.com/icyphy/lingua-franca}}. 
Lingua Franca is a complex framework that implements the Reactors model, described in Section~ref{sec:rectors}.
This novel language is a self-described polyglot \emph{coordination language}, which means that it is not used to define the computation but rather to compose reactors written in a different language.
Similar to \ac{CPN}, nothing prevents programmers from ``cheating'' in the code of the reactors and going around the semantics, yet it does enforce them more strongly than a library, as it is a full \ac{DSL} that generates Reactors-based applications in a source-to-source compilation process.
Figure~\ref{fig:audio_filter_lf} shows the Lingua Franca programming environment with an implementation of the audio filter benchmark.
We will not discuss the framework more in detail, as the design and implementation of Lingua Franca is not part of the contribution of this thesis.

\begin{figure}[t]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/audio_filter_lf_screenshot.png}
	\caption{The audio filter example in Lingua Franca}
	\label{fig:audio_filter_lf}
	%	\vspace{-1mm}
\end{figure}

In Chapter~\ref{chap:mapping} we discussed the \ac{CPN} language at length, as well as the \ac{MAPS} framework which is used to lower \ac{CPN} to different implementations in heterogeneous systems.
In contrast\footnote{As an extension of C, the \ac{CPN} language also does not fundamentally prevent programmers from breaking the semantics.}, e.g. the YAPI programming interface~\cite{yapi} defines process networks only as a runtime library and can be evaded just like Scala developers do with actor frameworks~\cite{tasharofi2013scala}.
The Sesame framework uses YAPI-based programs, e.g. derived from Compaan~\cite{stefanov2003deriving} for \ac{dse}\cite{pimentel2006systematic}.
Most of the software synthesis flows discussed in Section~\ref{sec:software_synthesis_flows} use the languages described here, e.g. TURNUS which uses CAL or SystemCoDesigner which is based on SystemC.
Other systems like DAARM or \mocasin do not use actual source code for the applications but rather application models for \ac{DSE}.


Most of the flows discussed above and in Section~\ref{sec:software_synthesis_flows} are academic and deal with more sophisticated models. 
Many ideas that seem good in academia do not hold up in a practical development environment, where the learning curve of the models and time-to-market considerations change the field.
It is therefore not surprising that the more sophisticated models have seen less adoption.
For example, the LabVIEW Communications System Design Suite restricts the LabVIEW language to a dataflow \ac{MoC}.
Matlab Simulink has a dataflow-like semantic with time triggering, thus closer to discrete event models.
On the discrete-events side 

\subsection{Implicit Dataflow}

The languages surveyed so far are explicit about their abstractions: Actors, Reactors or Processes are declared explicitly.
Similarly, channels describing the dataflow are made explicit either through channel declarations or through the connection of explicit ports.
A programmer writing in e.g. \ac{CPN} or Lingua Franca has to have a model of the network describing the application in their head (or in their \acs{IDE}).
Implicit abstractions, on the other hand, work by generating implicit models from linguistic constructs that don't exhibit their structure directly.

Implicit abstractions as we just defined them are ubiquitous in programming languages.
Again, objects in \ac{OOP} are an implicit abstraction for data encapsulation that is fundamentally similar to actors.
A thorough classification  of these implicit models is outside the scope of this thesis.
Instead, we will look closely at the Ohua programming paradigm~\cite{ertel_phdthesis}, which derives a dataflow execution from functional semantics.

The Ohua programming model by S. Ertel and others is a powerful model of implicit parallelism which can be used to express parallelism at a language level without explict costructions like threads and locks. 
\index{Ohua}
As stated above, the parallelism comes from lowering an Ohua program into a dataflow-based execution.
This model is not part of the original contribution of this thesis.
However, it is central to several distinct original contributions of the thesis, and we will introduce it as background material.

Ohua itself is a general paradigm that works on multiple language, and the framework has evolved over the years of its development.
The version of Ohua we will discuss here first is based on Clojure and Java, but the Ohua compiler and its principles work with many languages,
and rutimes also exist at different levels of development e.g. for Rust, Javascript or Go.
Ohua is best understood by diving directly into examples. Consider the code in Listing~\ref{listing:ohua_audio_filter}.

\begin{listing}
\begin{minted}[linenos]{Clojure}
 ;; TODO: add the audio filter solution code.
 (ns wav-transform.core
  (:gen-class)
  (:import WavTransform))

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (WavTransform/fromFile "oxp.wav" "oxp-transformed.wav")) 
\end{minted}
\caption{The Audio Filter Example written in Ohua}
\label{listing:ohua_audio_filter}
\end{listing}

Listing~\ref{listig:ohua_audio_filter} is based on Clojure, a dialect of Lisp.
It implements the same example from Chapter~\ref{chap:mapping} (cf. Listing~\ref{listing:audio_filter} or Figure~\ref{fig:audio_filter_graph}), a two-channel audio filter.
Internally, the compiler transforms this code into a dataflow graph for execution.
As a \ac{MoC}, this can be embeded in the Dennis dataflow models discussed in Chapter~\ref{chap:mocs}.
We will discuss the semantics of these dataflow graphs in Section~\ref{sec:ohua_dataflow}.
\todo{discuss example}.

The example in Figure~\ref{fig:ohua_example} can be transformed into a dataflow graph for execution. We will discuss this further in Section~\ref{sec:ohua_dataflow}.
The main advantage of this transformation is that a dataflow graph exposes concurrency, which can be exploited e.g. in a parallel execution or for optimizing \ac{I/O}(cf. Section~\ref{sec:yauhau}).
This duality between code and dataflow graphs is a core concept behind Ohua.
The other central pilar of the Ohua design concept are stateful functions, an abstraction that encapsulates functions with state and side-effects in the context of their dataflow execution.
\index{Ohua ! stateful functions}

\subsection{Stateful Functions}
The functional programming community has made the distinction between \emph{pure} and \emph{impure} functions widespread.
A pure function is a function in the mathematical sense of the word: it receives a certain input and, deterministically, produces an output.
This could be as simple as negating a boolean value, or as complicated as inference with a gargantuan deep neural network.
The main point is that the entirety of the usage of a function is that it returns a value in a deterministic fashion from its inputs.

In most imperative languages, like C or Java, functions usually also have side-effects. Writing the output to the terminal, storing data in a global data structure or even reading data from a sensor in a \ac{CPS}, these are all examples of side effects.
A language that only allows pure functions is basically useless, since even printing the result of a computation is impure.
Time is also fundamentally part of a computation, as we have discussed in Chapter~\ref{chap:mocs}, as can be an interaction with the outside world in the form of sensing and actuation in \acp{CPS}.

Stateful functions are a special abstraction, where the concept of pure functions is extended to consider the state of the computation. 
While this excludes aspects like the time of the computation and side-effects like actuation, it is general enough to cover large classes of functions used in most software.
A stateful function is a function $f : a \rightarrow b$ and an abstract state $S$, where the execution of the function can be seen as dependent of the state, which it also modifyies.
In other words, we consider $f$ as a function:
\begin{align}
  f : a \times S \rightarrow b \times S \label{eqn:state_thread}
\end{align}

Pure functions can be seen as a special case of stateful functions, with a trivial state $S = \{*\}$.

\begin{listing}
\begin{minted}[]{Java}
public class ParseVariable{
  @defsfn
  public ParseVariable (ExpressionObject expr, SymbolTable table){
    symbols = expr.parse();
    table.write(symbols);
    return(object);
  }
}
\end{minted}
\caption{An example of a stateful function.}
\label{listing:stateful_function}
\end{listing}


Listing~\ref{listing:stateful_function} shows an example of a stateful function, written in Java, which is identified as such by the \texttt{@defsfn} annotation.
TODO: Discuss (or improve) the example. Admittedly, I'm a bit confused by this, does the state have to be explicit as an input?
By anotating a function as stateful and being able to reason about its state, we can ensure its semantics are preserved when transforming to a dataflow execution.
Traditionally, stateful functions in Ohua are explicitly annotated as such~\cite{ertel_pmam18}.

\subsection{Dataflow Execution}
\label{sec:ohua_dataflow}


Figure~\ref{fig:ohua_example_df} depicts this example as a dataflow graph.
\todo{discuss dataflow graph}.


Ohua

The Ohua framework is based on these two design principles, yet the implementation has constantly evolved since its original inception~\cite{ertel2014framework}.
The work we will present in this chapter played a role in Ohua's evolution.
For this reason, we will discuss the concrete language and transformations in the context they were developed, instead of the latest instantiation of Ohua.

The concepts of Ohua itself and the implementation of the compiler are beyond the scope of this thesis. 
The rest of this chapter will focus mostly on formalizing the semantics and defining semantics-preserving transformations. 
Note that is the joint contribution of a collaborative work with multiple co-authors in~\cite{goens_multiprog18,ertel_cc18,ertel_haskell19,ertel_haskellsup19}.